<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Munchers: Arcade Edition</title>
    <style>
        body {
            background-color: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.1);
            border: 4px solid #444;
            border-radius: 10px;
            background: #000;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-bar {
            background: rgba(0, 20, 0, 0.8);
            color: #0f0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            font-weight: bold;
            border-bottom: 2px solid #0f0;
            text-transform: uppercase;
            text-shadow: 0 0 5px #0f0;
        }

        .bottom-bar {
            border-top: 2px solid #0f0;
            border-bottom: none;
            font-size: 14px;
            justify-content: center;
        }

        /* MENUS */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 { font-size: 48px; color: #0f0; text-shadow: 4px 4px 0 #004400; margin-bottom: 20px; }
        h2 { font-size: 32px; color: #fff; margin-bottom: 10px; }
        p { color: #ccc; font-size: 18px; max-width: 600px; text-align: center; margin-bottom: 30px; }

        button {
            background: #000;
            color: #0f0;
            border: 3px solid #0f0;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 24px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        button:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }

        .lives-display { display: flex; gap: 5px; }
        .life-icon { width: 20px; height: 20px; background: #0f0; border-radius: 50%; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="ui-layer">
            <div class="hud-bar">
                <span id="score-el">Score: 0</span>
                <span id="rule-el">LOADING...</span>
                <div class="lives-display" id="lives-el">
                    <!-- Lives injected here -->
                </div>
            </div>
            <div class="hud-bar bottom-bar">
                ARROWS to Move &nbsp;&bullet;&nbsp; SPACE to Munch &nbsp;&bullet;&nbsp; 'H' for Hint
            </div>
        </div>

        <!-- MAIN MENU -->
        <div id="menu-screen" class="overlay">
            <h1>NUMBER MUNCHERS</h1>
            <p>Help the Muncher eat all the correct numbers. Watch out for the Troggles!</p>
            <div>
                <button onclick="Game.init('multiples')">Multiples</button>
                <button onclick="Game.init('factors')">Factors</button>
            </div>
        </div>

        <!-- LEVEL TRANSITION -->
        <div id="level-screen" class="overlay hidden">
            <h2 id="level-title">LEVEL 1</h2>
            <p id="level-rule">Find Multiples of 5</p>
            <button onclick="Game.startLevel()">START</button>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color:red">GAME OVER</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>

    <script>
        /**
         * MATH MUNCHER: ARCADE EDITION
         * * --- TEACHER SETTINGS ---
         * You can adjust the difficulty and numbers here.
         */
        
        const TEACHER_SETTINGS = {
            STARTING_LIVES: 3,
            
            // MULTIPLES MODE:
            // "Easy" is used for Levels 1-2.
            // "Hard" is added to the mix for Level 3+.
            MULTIPLES_EASY: [2, 5, 10], 
            MULTIPLES_HARD: [3, 4, 6, 7, 8, 9, 11, 12],
            
            // FACTORS MODE:
            // "Easy" numbers (Levels 1-2) have obvious factors.
            // "Hard" numbers (Level 3+) are larger composites.
            FACTORS_EASY: [10, 12, 15, 16, 20, 24, 25],
            FACTORS_HARD: [18, 28, 30, 32, 36, 40, 42, 45, 48, 50, 56, 60, 64, 72, 80],

            // How many correct answers must be on the board minimum?
            MIN_CORRECT_ANSWERS: 3
        };


        /* --- GAME ENGINE (Do not edit below unless comfortable with JS) --- */

        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GRID_COLS = 6;
        const GRID_ROWS = 5;
        const TOP_OFFSET = 60; // Space for HUD
        
        // Calculated dimensions
        const CELL_W = CANVAS_WIDTH / GRID_COLS;
        const CELL_H = (CANVAS_HEIGHT - TOP_OFFSET) / GRID_ROWS;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game State
        const Game = {
            mode: 'multiples', // or 'factors'
            level: 1,
            score: 0,
            lives: 3,
            targetNumber: 0,
            
            // State Machine: 'menu', 'playing', 'dying', 'gameover'
            state: 'menu', 
            
            lastFrameTime: 0,
            grid: [],
            enemies: [],
            particles: [],
            
            // Animation variables
            deathTimer: 0,
            deathDuration: 60, // Frames (approx 1 sec)
            
            // Player Object
            player: {
                gx: 0, gy: 0, // Grid coordinates
                x: 0, y: 0,   // Pixel coordinates
                dir: 'right', 
                mouthOpen: false,
                mouthTimer: 0,
                angle: 0,      // For death spin
                scale: 1       // For death shrink
            },

            init: function(mode) {
                this.mode = mode;
                this.score = 0;
                this.lives = TEACHER_SETTINGS.STARTING_LIVES;
                this.level = 1;
                document.getElementById('menu-screen').classList.add('hidden');
                this.setupLevel();
            },

            setupLevel: function() {
                this.state = 'playing';
                this.player.gx = 0;
                this.player.gy = 0;
                this.player.angle = 0;
                this.player.scale = 1;
                
                this.enemies = [];
                this.particles = [];
                
                // --- PROGRESSION LOGIC ---
                let pool = [];
                if (this.mode === 'multiples') {
                    if (this.level <= 2) {
                        pool = TEACHER_SETTINGS.MULTIPLES_EASY;
                    } else {
                        pool = [...TEACHER_SETTINGS.MULTIPLES_EASY, ...TEACHER_SETTINGS.MULTIPLES_HARD];
                    }
                } else {
                    if (this.level <= 2) {
                        pool = TEACHER_SETTINGS.FACTORS_EASY;
                    } else {
                        pool = [...TEACHER_SETTINGS.FACTORS_EASY, ...TEACHER_SETTINGS.FACTORS_HARD];
                    }
                }
                
                // Pick random number from the determined pool
                this.targetNumber = pool[Math.floor(Math.random() * pool.length)];

                this.generateGrid();
                this.updateHUD();

                // Show Level Screen
                const title = this.mode === 'multiples' ? `Multiples of ${this.targetNumber}` : `Factors of ${this.targetNumber}`;
                document.getElementById('level-title').innerText = `LEVEL ${this.level}`;
                document.getElementById('level-rule').innerText = `Find: ${title}`;
                document.getElementById('level-screen').classList.remove('hidden');
            },

            startLevel: function() {
                document.getElementById('level-screen').classList.add('hidden');
                
                // Reset player pixel pos
                this.player.x = this.player.gx * CELL_W + (CELL_W/2);
                this.player.y = this.player.gy * CELL_H + (CELL_H/2) + TOP_OFFSET;
                
                this.lastFrameTime = performance.now();
                
                // Start Loop if not already running
                requestAnimationFrame(gameLoop);

                // Start Enemy Spawner
                setTimeout(() => this.spawnEnemy(), 3000); 
            },

            generateGrid: function() {
                this.grid = [];
                let validCount = 0;
                
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        let val, isValid;
                        const isTarget = Math.random() < 0.4; 

                        if (this.mode === 'multiples') {
                            if (isTarget) {
                                val = this.targetNumber * (Math.floor(Math.random() * 10) + 1);
                                isValid = true;
                            } else {
                                do {
                                    val = Math.floor(Math.random() * (this.targetNumber * 10)) + 1;
                                } while (val % this.targetNumber === 0);
                                isValid = false;
                            }
                        } else {
                            if (isTarget) {
                                let factors = [];
                                for(let i=1; i<=this.targetNumber; i++) {
                                    if(this.targetNumber % i === 0) factors.push(i);
                                }
                                val = factors[Math.floor(Math.random() * factors.length)];
                                isValid = true;
                            } else {
                                do {
                                    val = Math.floor(Math.random() * this.targetNumber) + 1;
                                } while (this.targetNumber % val === 0);
                                isValid = false;
                            }
                        }

                        if(isValid) validCount++;

                        this.grid.push({
                            c: c, r: r,
                            val: val,
                            isValid: isValid,
                            eaten: false,
                            color: '#0f0',
                            highlightTimer: 0
                        });
                    }
                }
                if(validCount < TEACHER_SETTINGS.MIN_CORRECT_ANSWERS) this.generateGrid();
            },

            spawnEnemy: function() {
                if(this.state !== 'playing') return;

                // Max enemies scales with level
                let maxEnemies = Math.min(1 + Math.floor(this.level/2), 4);
                
                if(this.enemies.length < maxEnemies) {
                    let gx, gy;
                    if(Math.random() > 0.5) {
                        gx = Math.random() > 0.5 ? -1 : GRID_COLS;
                        gy = Math.floor(Math.random() * GRID_ROWS);
                    } else {
                        gx = Math.floor(Math.random() * GRID_COLS);
                        gy = Math.random() > 0.5 ? -1 : GRID_ROWS;
                    }

                    // Types: 0 = Wanderer (Red), 1 = Hunter (Purple)
                    let type = 0; 
                    if(this.level >= 3 && Math.random() > 0.5) type = 1;

                    this.enemies.push({
                        gx: gx, gy: gy,
                        x: gx * CELL_W + (CELL_W/2),
                        y: gy * CELL_H + (CELL_H/2) + TOP_OFFSET,
                        type: type,
                        moveTimer: 0,
                        moveInterval: type === 1 ? 80 : 120 
                    });
                }

                let nextTime = 3000 + Math.random() * 5000;
                if(this.level > 2) nextTime -= 1000;
                setTimeout(() => this.spawnEnemy(), nextTime);
            },

            updateHUD: function() {
                document.getElementById('score-el').innerText = `Score: ${this.score}`;
                const ruleText = this.mode === 'multiples' ? `Multiples of ${this.targetNumber}` : `Factors of ${this.targetNumber}`;
                document.getElementById('rule-el').innerText = ruleText;
                
                const livesContainer = document.getElementById('lives-el');
                livesContainer.innerHTML = '';
                for(let i=0; i<this.lives; i++) {
                    const d = document.createElement('div');
                    d.className = 'life-icon';
                    livesContainer.appendChild(d);
                }
            },
            
            triggerDeath: function() {
                if (this.state === 'dying') return;
                
                this.state = 'dying';
                this.deathTimer = this.deathDuration;
                
                // Spawn red particles at player location
                spawnParticles(this.player.x, this.player.y, '#f00', 20);
            },

            resolveDeath: function() {
                this.lives--;
                this.updateHUD();

                if (this.lives <= 0) {
                    this.state = 'gameover';
                    document.getElementById('final-score').innerText = this.score;
                    document.getElementById('game-over-screen').classList.remove('hidden');
                } else {
                    // Respawn
                    this.state = 'playing';
                    this.player.gx = 0;
                    this.player.gy = 0;
                    this.player.angle = 0;
                    this.player.scale = 1;
                    this.player.x = this.player.gx * CELL_W + (CELL_W/2);
                    this.player.y = this.player.gy * CELL_H + (CELL_H/2) + TOP_OFFSET;
                    
                    this.enemies = []; // Clear enemies for fairness
                }
            },
            
            checkWin: function() {
                const remaining = this.grid.filter(c => !c.eaten && c.isValid);
                if (remaining.length === 0) {
                    this.level++;
                    this.score += 500;
                    // Small delay before next level
                    setTimeout(() => {
                        this.setupLevel();
                    }, 500);
                }
            },

            hint: function() {
                if(this.state !== 'playing') return;
                const targets = this.grid.filter(c => c.isValid && !c.eaten);
                if (targets.length > 0) {
                    const t = targets[Math.floor(Math.random() * targets.length)];
                    t.highlightTimer = 60; 
                }
            }
        };

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', e => {
            if (Game.state !== 'playing') return;

            const p = Game.player;
            let didMove = false;

            switch(e.key) {
                case 'ArrowUp': 
                    if (p.gy > 0) { p.gy--; didMove = true; }
                    break;
                case 'ArrowDown': 
                    if (p.gy < GRID_ROWS - 1) { p.gy++; didMove = true; }
                    break;
                case 'ArrowLeft': 
                    if (p.gx > 0) { p.gx--; p.dir = 'left'; didMove = true; }
                    break;
                case 'ArrowRight': 
                    if (p.gx < GRID_COLS - 1) { p.gx++; p.dir = 'right'; didMove = true; }
                    break;
                case ' ':
                    munch();
                    break;
                case 'h':
                case 'H':
                    Game.hint();
                    break;
            }
        });

        function munch() {
            const p = Game.player;
            const idx = p.gy * GRID_COLS + p.gx;
            const cell = Game.grid[idx];

            p.mouthOpen = true;
            p.mouthTimer = 10; 

            if (!cell.eaten) {
                if (cell.isValid) {
                    // Correct!
                    cell.eaten = true;
                    Game.score += 50;
                    Game.updateHUD();
                    spawnParticles(p.x, p.y, '#0f0', 10);
                    Game.checkWin();
                } else {
                    // Wrong!
                    Game.triggerDeath();
                }
            }
        }

        function spawnParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                Game.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 40,
                    color: color
                });
            }
        }

        // --- GAME LOOP ---
        function gameLoop(timestamp) {
            if (Game.state === 'gameover') return; // Stop loop on game over

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw Grid Lines
            ctx.strokeStyle = '#004400';
            ctx.lineWidth = 2;
            for(let x=0; x<=GRID_COLS; x++) {
                ctx.beginPath(); ctx.moveTo(x*CELL_W, TOP_OFFSET); ctx.lineTo(x*CELL_W, CANVAS_HEIGHT); ctx.stroke();
            }
            for(let y=0; y<=GRID_ROWS; y++) {
                const Y = y*CELL_H + TOP_OFFSET;
                ctx.beginPath(); ctx.moveTo(0, Y); ctx.lineTo(CANVAS_WIDTH, Y); ctx.stroke();
            }

            // Draw Numbers
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            Game.grid.forEach(cell => {
                if (!cell.eaten) {
                    const cx = cell.c * CELL_W + (CELL_W/2);
                    const cy = cell.r * CELL_H + (CELL_H/2) + TOP_OFFSET;
                    
                    if (cell.highlightTimer > 0) {
                        ctx.save();
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 0.3; 
                        ctx.fillRect(cell.c * CELL_W, cell.r * CELL_H + TOP_OFFSET, CELL_W, CELL_H);
                        ctx.restore();
                        cell.highlightTimer--;
                        ctx.fillStyle = '#fff'; 
                    } else {
                        ctx.fillStyle = cell.color;
                    }
                    ctx.fillText(cell.val, cx, cy);
                }
            });

            // LOGIC SPLIT: PLAYING vs DYING
            if (Game.state === 'playing') {
                updatePlayingState();
            } else if (Game.state === 'dying') {
                updateDyingState();
            }

            // Always Draw Enemies (even if paused/dying, keep them on screen)
            Game.enemies.forEach(en => {
                const ex = en.gx * CELL_W + (CELL_W/2);
                const ey = en.gy * CELL_H + (CELL_H/2) + TOP_OFFSET;
                
                // Only interpolate movement if playing
                if (Game.state === 'playing') {
                    en.x += (ex - en.x) * 0.1;
                    en.y += (ey - en.y) * 0.1;
                }
                drawTroggle(ctx, en.x, en.y, en.type);
            });

            // Always Draw Particles
            for(let i=Game.particles.length-1; i>=0; i--) {
                const pt = Game.particles[i];
                pt.x += pt.vx;
                pt.y += pt.vy;
                pt.life--;
                ctx.fillStyle = pt.color;
                ctx.fillRect(pt.x, pt.y, 4, 4);
                if(pt.life <= 0) Game.particles.splice(i, 1);
            }

            requestAnimationFrame(gameLoop);
        }

        function updatePlayingState() {
            const p = Game.player;
            const targetX = p.gx * CELL_W + (CELL_W/2);
            const targetY = p.gy * CELL_H + (CELL_H/2) + TOP_OFFSET;
            
            p.x += (targetX - p.x) * 0.2;
            p.y += (targetY - p.y) * 0.2;

            if (p.mouthTimer > 0) p.mouthTimer--;
            else p.mouthOpen = false;

            drawMuncher(ctx, p.x, p.y, p.dir, p.mouthOpen, 0, 1);

            // Update Enemies
            Game.enemies.forEach(en => {
                en.moveTimer++;
                if (en.moveTimer > en.moveInterval) {
                    en.moveTimer = 0;
                    
                    let possibleMoves = [];
                    if (en.gx > 0) possibleMoves.push({x:-1, y:0});
                    if (en.gx < GRID_COLS-1) possibleMoves.push({x:1, y:0});
                    if (en.gy > 0) possibleMoves.push({x:0, y:-1});
                    if (en.gy < GRID_ROWS-1) possibleMoves.push({x:0, y:1});
                    
                    if (en.type === 1) { // Hunter
                        let bestMove = possibleMoves[0];
                        let minDist = 999;
                        possibleMoves.forEach(m => {
                            let dist = Math.abs((en.gx + m.x) - p.gx) + Math.abs((en.gy + m.y) - p.gy);
                            if (dist < minDist) { minDist = dist; bestMove = m; }
                        });
                        if(Math.random() < 0.2) bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        if(bestMove) { en.gx += bestMove.x; en.gy += bestMove.y; }
                    } else { // Wanderer
                        const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        if(move) { en.gx += move.x; en.gy += move.y; }
                    }
                }
                
                // Collision
                if (en.gx === p.gx && en.gy === p.gy) {
                    Game.triggerDeath();
                }
            });
        }

        function updateDyingState() {
            // Animate Player Death
            Game.deathTimer--;
            const p = Game.player;
            
            // Spin and shrink effect
            p.angle += 0.4; 
            p.scale -= 1 / Game.deathDuration;
            if(p.scale < 0) p.scale = 0;

            drawMuncher(ctx, p.x, p.y, p.dir, true, p.angle, p.scale);

            if (Game.deathTimer <= 0) {
                Game.resolveDeath();
            }
        }

        // --- DRAWING HELPERS ---

        function drawMuncher(ctx, x, y, dir, mouthOpen, angle, scale) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.scale(scale, scale);
            
            if(dir === 'left') ctx.scale(-1, 1);
            
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.fillStyle = '#000';
            ctx.beginPath();
            if (mouthOpen) {
                ctx.moveTo(0, 0);
                ctx.lineTo(30, -15);
                ctx.lineTo(30, 15);
            } else {
                ctx.moveTo(0, 0);
                ctx.lineTo(25, 0);
            }
            ctx.fill();

            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(5, -10, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawTroggle(ctx, x, y, type) {
            ctx.save();
            ctx.translate(x, y);
            
            const wobble = Math.sin(Date.now() / 100) * 3;
            
            ctx.fillStyle = type === 0 ? '#ff4444' : '#aa00aa'; 
            
            ctx.beginPath();
            ctx.moveTo(-20, 20);
            ctx.lineTo(-20 + wobble, -10);
            ctx.bezierCurveTo(-10, -30, 10, -30, 20 + wobble, -10);
            ctx.lineTo(20, 20);
            
            for(let i=20; i>=-20; i-=10) {
                ctx.lineTo(i-5, 15);
                ctx.lineTo(i-10, 20);
            }
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-8, -5, 6, 0, Math.PI*2);
            ctx.arc(8, -5, 6, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-8 + (Math.random()*2-1), -5, 2, 0, Math.PI*2);
            ctx.arc(8 + (Math.random()*2-1), -5, 2, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

    </script>
</body>
</html>
